//线段树
struct Segment_Tree{

	struct SGT_node{
		ll a;
	}tree[maxn<<2];

	ll lazy[maxn<<2];

	void push_up(int rt){
		tree[rt].a = tree[rt<<1].a + tree[rt<<1|1].a;
	}

	void build(int l,int r,int rt,vector<ll>& a){
		lazy[rt] = 0;
		if(l==r){
			tree[rt].a = a[l-1];
			return;
		}
		int m = (l+r)>>1;
		build(l,m,rt<<1,a);
		build(m+1,r,rt<<1|1,a);
		push_up(rt);
	}

	void push_down(int l,int r,int rt){
		if(lazy[rt]){
			lazy[rt<<1] += lazy[rt];
			lazy[rt<<1|1] += lazy[rt];
			int m = (l+r)>>1;
			tree[rt<<1].a += lazy[rt]*(ll)(m-l+1);
			tree[rt<<1|1].a += lazy[rt]*(ll)(r-m);
			lazy[rt] = 0;
		}
	}

	void update(int L,int R,ll k,int l,int r,int rt){
		if(L<=l&&r<=R)
		{
			tree[rt].a += k*(ll)(r-l+1);
			lazy[rt] += k;
			return;
		}
		push_down(l,r,rt);
		int m = (l+r)>>1;
		if(L<=m)
			update(L,R,k,l,m,rt<<1);
		if(R>m)
			update(L,R,k,m+1,r,rt<<1|1);
		push_up(rt);
	}

	SGT_node query(int L,int R,int l,int r,int rt){
		if(L<=l&&r<=R)
			return tree[rt];
		push_down(l,r,rt);
		int m = (l+r)>>1;
		if(R<=m)
			return query(L,R,l,m,rt<<1);
		else if(L>m)
			return query(L,R,m+1,r,rt<<1|1);
		else{
			SGT_node a = query(L,R,l,m,rt<<1);
			SGT_node b = query(L,R,m+1,r,rt<<1|1);
			SGT_node c;
			c.a = a.a+b.a;
			return c;
		}
	}

};